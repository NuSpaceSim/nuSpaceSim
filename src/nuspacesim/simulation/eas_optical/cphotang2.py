"""
Cherenkov Photon Angle and Photon Sum.

author: Alexander Reustle
date: 2023 April 7
"""

import cubepy as cp
import numpy as np

from . import atmospheric_models as atm
from . import shower_properties as shp


def photon_yield_per_particle_step(
    z, beta_tr, thetaC, X_ahead, detector_altitude, abstol=1e-6, reltol=1e-6
):
    """
    Quantity of photons generated by showers, with consideration for absorption and
    from ozone, and aerosol & Rayleigh scatter.
    """

    def df(w, evt_idx, z_, beta_tr_, thetaC_, X_ahead_):
        """
        Differential proportion of photons generated and not scattered.
        """
        return shp.cherenkov_yield(
            w,
            detector_altitude,
            z_[evt_idx],
            beta_tr_[evt_idx],
            thetaC_[evt_idx],
            X_ahead_[evt_idx],
        )

    return cp.integrate(
        df,
        200.0,  # low wavellength (nm)
        900.0,  # high wavellength (nm)
        args=(z, beta_tr, thetaC, X_ahead),
        is_1d=True,
        evt_idx_arg=True,
        abstol=abstol,
        reltol=reltol,
        tile_byte_limit=2**25,
        parallel=False,
    )


def cherenkov_cone_charged_particles(
    index_of_refraction_air, shower_age, abstol=1e-6, reltol=1e-6
):
    def df(logenergy, costheta, evt_idx, shower_age_):
        return shp.cherenkov_cone_particle_count_integrand(
            logenergy, costheta, shower_age_[evt_idx]
        )

    return cp.integrate(
        df,
        (1.0, np.zeros_like(index_of_refraction_air)),
        (17.0, np.reciprocal(index_of_refraction_air)),
        args=(shower_age),
        is_1d=True,
        evt_idx_arg=True,
        abstol=abstol,
        reltol=reltol,
        tile_byte_limit=2**25,
        parallel=False,
    )


def tmp_setup(beta_tr, decay_altitude):
    """
    single step event-wise eas cphotang computation.
    """

    detector_altitude = 100.0  # km
    dL = 0.1

    # Shower Age start and stop
    # s0 = np.exp(-1150/454) <-- e2hill == 0: Shower too young.
    shower_age_begin = np.exp(-1150.0 / 454.0) + np.finfo.eps  # ~0.07941725256837101449
    # shower age when greisen_particle_count(s) == 1.0.
    shower_age_end = 1.899901462640018

    # Determine the altitude bounds (in km) over which each shower will be measurable.
    alt_lo = shp.altitude_at_shower_age(shower_age_begin, decay_altitude, beta_tr)
    alt_hi = shp.altitude_at_shower_age(shower_age_end, decay_altitude, beta_tr)
    alt_lo[alt_lo >= detector_altitude] = detector_altitude
    alt_hi[alt_hi >= detector_altitude] = detector_altitude

    # Determine the path lengths (in km) of measurable showers
    path_len_begin = shp.path_length_tau_atm(alt_lo, beta_tr)
    path_len_end = shp.path_length_tau_atm(alt_hi, beta_tr)
    path_length_measurable = path_len_end - path_len_begin

    # sanity check. TODO pull out into unit test
    check_alt_lo = shp.altitude_along_path_length(path_len_begin, beta_tr)
    check_alt_hi = shp.altitude_along_path_length(path_len_end, beta_tr)
    assert np.allclose(check_alt_lo, alt_lo)
    assert np.allclose(check_alt_hi, alt_hi)

    # We will step in 100m increments. Determine event_wise integer number of shower
    # propagation steps.
    eventwise_steps = np.ceil(path_length_measurable * (1.0 / dL)).astype(np.uint)
    steps_max = np.max(eventwise_steps)
    # full_steps = np.arange(steps_max)

    photon_sum = np.zeros_like(beta_tr)

    # Naive looping implementation
    for i in range(steps_max):

        m0 = i > eventwise_steps  # Altitude Mask

        # Compute Altitudes for Target Events
        path_length_m = path_len_begin[m0] + (dL * i)
        z_m = shp.altitude_along_path_length(path_length_m, beta_tr[m0])

        # Compute the atmosphereic and shower properties used for early stopping.
        X_behind, X_ahead = atm.slant_depth_trig_behind_ahead(
            alt_lo[m0], z_m, alt_hi[m0], (0.5 * np.pi) - beta_tr[m0]
        )
        index_of_refraction = atm.index_of_refraction_air(z_m)
        particle_N, shower_age = shp.greisen_particle_count_shower_age(X_behind)
        e2hill = 1150.0 + 454.0 * np.log(shower_age)

        # Compute the set of events to skip and create a mask for them.
        m1 = (
            (index_of_refraction != 1.0)
            & (index_of_refraction != 0.0)
            & ~((particle_N < 1.0) & (shower_age > 1.0))
            & (e2hill > 0.0)
        )

        # Mask out the skipped events
        z_m = z_m[m1]
        beta_tr_m = beta_tr[m0][m1]
        X_behind = X_behind[m1]
        X_ahead = X_ahead[m1]
        index_of_refraction = index_of_refraction[m1]
        particle_N = particle_N[m1]
        shower_age = shower_age[m1]

        # Relevant Properties
        pyield = photon_yield_per_particle_step(
            z_m,
            beta_tr_m,
            detector_altitude,
            atm.cherenkov_angle(index_of_refraction),
            X_ahead,
        )

        particle_proportion = cherenkov_cone_charged_particles(
            index_of_refraction, shower_age
        )

        photon_sum[m0][m1] += particle_N * (1e3 * dL) * pyield * particle_proportion
